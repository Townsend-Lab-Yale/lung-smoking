install.packages('crso')
library(crso)
library(crso)
library(foreach)
n.cores <- 1
### Set up parallel backend, example with doMC:
#n.cores <- detectCores()
#library(doMC); registerDoMC(n.cores)
### Load example dataset consisting of TCGA melanoma (SKCM) patients.
data(skcm)
list2env(skcm.list,envir=globalenv())
names(skcm.list) ### load D, P and cnv.dictionary
Q <- log10(P) ### Q is the penalty matrix derived from P
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(crso)
library(foreach)
n.cores <- 1
### Set up parallel backend, example with doMC:
#n.cores <- detectCores()
#library(doMC); registerDoMC(n.cores)
### Load example dataset consisting of TCGA melanoma (SKCM) patients.
data(skcm)
list2env(skcm.list,envir=globalenv())
names(skcm.list) ### load D, P and cnv.dictionary
Q <- log10(P) ### Q is the penalty matrix derived from P
View(skcm.list)
### Coverage parameters
rule.thresh <- .05
msa <- ceiling(ncol(D)*rule.thresh)
### Phase-1 parameters
spr <- 1 # Phase 1 random sets per rule (default = 20, recommend at least 10)
trn <- 30 # Phase 1 stop criteria (default = 24, recommend at most 30)
cut.size <- 0.5 # Fraction of low scoring rules per iteration
### P2 parameters
k.max.2 <- 4
max.nrs.p2 <- 10000 # (default is 200000)
max.compute.p2 <- 5*max.nrs.p2
max.stored.p2 <- 10 # (default is 10)
### P3 parameters
max.nrs.p3 <- 10000 # (default is 200000)
max.stored.p3 <- 10 # (default is 10)
### P4 parameters
k.max.4 <- 8 # default is 40
max.nrs.p4 <- 10000 # max RS per evaluated per next K (default is 100)
max.stored.p4 <- 100
### GC parameters
gc.iter <- 10 # Number GC iterations (default is 100)
gc.eval <- 10 # RS of each K evaluated per GC iteration (default is 100)
r.seed <- 100
set.seed(r.seed)
params.vec <- c(n.cores = n.cores, msa = msa, rule.thresh = rule.thresh,
spr = spr, trn = trn, cut.size = cut.size,
k.max.2 = k.max.2, max.nrs.p2 = max.nrs.p2,
max.stored.p2= max.stored.p2,max.nrs.p3 = max.nrs.p3,
max.stored.p3 = max.stored.p3,k.max.4 = k.max.4,
max.nrs.p4 = max.nrs.p4, max.stored.p4 = max.stored.p4,
gc.iter = gc.iter, gc.eval = gc.eval,r.seed=r.seed)
### initialize timing vect
timing.vec <- rep(NA,length=7)
names(timing.vec) <- c("P1","PS","P2","P3","P4","GC","Total")
rm.start <- buildRuleLibrary(D,rule.thresh)
print(paste0("Dimensions of rm start = ",paste0(dim(rm.start),collapse = " ")))
### "Dimensions of rm start = 60 71"
full.results.list <- list(params.vec = params.vec, D = D, P = P, Q = Q,
rm.start = rm.start, timing.vec = timing.vec)
beg <- Sys.time()
print("Starting Phase One")
rm.ordered <- runPhaseOne(D,Q,rm.start,cut.size=cut.size,spr=spr,trn=trn,shouldPrint = TRUE)
??runPhaseOne
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(crso)
library(foreach)
n.cores <- 1
### Set up parallel backend, example with doMC:
#n.cores <- detectCores()
#library(doMC); registerDoMC(n.cores)
### Load example dataset consisting of TCGA melanoma (SKCM) patients.
data(skcm)
list2env(skcm.list,envir=globalenv())
names(skcm.list) ### load D, P and cnv.dictionary
Q <- log10(P) ### Q is the penalty matrix derived from P
### Coverage parameters
rule.thresh <- .05
msa <- ceiling(ncol(D)*rule.thresh)
### Phase-1 parameters
spr <- 1 # Phase 1 random sets per rule (default = 20, recommend at least 10)
trn <- 30 # Phase 1 stop criteria (default = 24, recommend at most 30)
cut.size <- 0.5 # Fraction of low scoring rules per iteration
### P2 parameters
k.max.2 <- 4
max.nrs.p2 <- 10000 # (default is 200000)
max.compute.p2 <- 5*max.nrs.p2
max.stored.p2 <- 10 # (default is 10)
### P3 parameters
max.nrs.p3 <- 10000 # (default is 200000)
max.stored.p3 <- 10 # (default is 10)
### P4 parameters
k.max.4 <- 8 # default is 40
max.nrs.p4 <- 10000 # max RS per evaluated per next K (default is 100)
max.stored.p4 <- 100
### GC parameters
gc.iter <- 10 # Number GC iterations (default is 100)
gc.eval <- 10 # RS of each K evaluated per GC iteration (default is 100)
r.seed <- 100
set.seed(r.seed)
params.vec <- c(n.cores = n.cores, msa = msa, rule.thresh = rule.thresh,
spr = spr, trn = trn, cut.size = cut.size,
k.max.2 = k.max.2, max.nrs.p2 = max.nrs.p2,
max.stored.p2= max.stored.p2,max.nrs.p3 = max.nrs.p3,
max.stored.p3 = max.stored.p3,k.max.4 = k.max.4,
max.nrs.p4 = max.nrs.p4, max.stored.p4 = max.stored.p4,
gc.iter = gc.iter, gc.eval = gc.eval,r.seed=r.seed)
### initialize timing vect
timing.vec <- rep(NA,length=7)
names(timing.vec) <- c("P1","PS","P2","P3","P4","GC","Total")
rm.start <- buildRuleLibrary(D,rule.thresh)
print(paste0("Dimensions of rm start = ",paste0(dim(rm.start),collapse = " ")))
### "Dimensions of rm start = 60 71"
full.results.list <- list(params.vec = params.vec, D = D, P = P, Q = Q,
rm.start = rm.start, timing.vec = timing.vec)
beg <- Sys.time()
print("Starting Phase One")
runPhaseOne <- function(D,Q,rm.start,cut.size,spr,trn,n.splits,shouldPrint){
if(missing(shouldPrint)) shouldPrint <- TRUE
if(missing(spr)) spr <- 10
if(missing(trn)) trn <- 20 ### Target rule number
if(missing(cut.size)) cut.size <- 0.5
if(missing(n.splits)) n.splits <- foreach::getDoParWorkers()
if(nrow(rm.start)<=trn){
if(shouldPrint) print("RM fewer than TRN. Proceed to phase two with rm.start.")
return(NULL)
}
beg <- Sys.time()
rm <- rm.start
order.vec <- c()
go <- 1
if(shouldPrint) print(paste0("Starting rules = ",nrow(rm)))
while(go){
rsm <- makeScaledRSM(D,rm,spr,Q,n.splits)
scores <- rowMeans(rsm)
ntbr <- min(floor(cut.size*nrow(rm)),nrow(rm)-trn) # number of rules to be removed
bad.thresh <- sort(scores,decreasing=FALSE)[ntbr]
order.vec <- c(order.vec,names(sort(scores,decreasing=FALSE)[1:ntbr]))
rm <- rm[which(scores>bad.thresh),]
if(shouldPrint) print(paste0("Remaining rules = ",nrow(rm)))
if(nrow(rm)<=trn) go <- 0 ### Should always be equal not less
}
rsm <- makeScaledRSM(D,rm,spr,Q,n.splits)
scores <- rowMeans(rsm)
order.vec <- c(order.vec,names(sort(scores,decreasing = FALSE)))
### Reverse order of order vec
order.vec <- order.vec[length(order.vec):1]
rm.final <- rm.start[order.vec,]
if(shouldPrint) print(difftime(Sys.time(),beg,units="min"))
return(rm.final)
}
rm.ordered <- runPhaseOne(D,Q,rm.start,cut.size=cut.size,spr=spr,trn=trn,shouldPrint = TRUE)
library(crso)
beg <- Sys.time()
print("Starting Phase One")
runPhaseOne <- function(D,Q,rm.start,cut.size,spr,trn,n.splits,shouldPrint){
if(missing(shouldPrint)) shouldPrint <- TRUE
if(missing(spr)) spr <- 10
if(missing(trn)) trn <- 20 ### Target rule number
if(missing(cut.size)) cut.size <- 0.5
if(missing(n.splits)) n.splits <- foreach::getDoParWorkers()
if(nrow(rm.start)<=trn){
if(shouldPrint) print("RM fewer than TRN. Proceed to phase two with rm.start.")
return(NULL)
}
beg <- Sys.time()
rm <- rm.start
order.vec <- c()
go <- 1
if(shouldPrint) print(paste0("Starting rules = ",nrow(rm)))
while(go){
rsm <- makeScaledRSM(D,rm,spr,Q,n.splits)
scores <- rowMeans(rsm)
ntbr <- min(floor(cut.size*nrow(rm)),nrow(rm)-trn) # number of rules to be removed
bad.thresh <- sort(scores,decreasing=FALSE)[ntbr]
order.vec <- c(order.vec,names(sort(scores,decreasing=FALSE)[1:ntbr]))
rm <- rm[which(scores>bad.thresh),]
if(shouldPrint) print(paste0("Remaining rules = ",nrow(rm)))
if(nrow(rm)<=trn) go <- 0 ### Should always be equal not less
}
rsm <- makeScaledRSM(D,rm,spr,Q,n.splits)
scores <- rowMeans(rsm)
order.vec <- c(order.vec,names(sort(scores,decreasing = FALSE)))
### Reverse order of order vec
order.vec <- order.vec[length(order.vec):1]
rm.final <- rm.start[order.vec,]
if(shouldPrint) print(difftime(Sys.time(),beg,units="min"))
return(rm.final)
}
rm.ordered <- runPhaseOne(D,Q,rm.start,cut.size=cut.size,spr=spr,trn=trn,shouldPrint = TRUE)
